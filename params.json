{
  "name": "Fall2016-project-bradyshutt",
  "tagline": "fall2016-project-bradyshutt created by GitHub Classroom",
  "body": "# Coplan\r\n\r\nBrady Shutt's project for CPE-305\r\n\r\n\r\n[coplan.bshutt.com](http://coplan.bshutt.com/)\r\n\r\n[![Build Status](https://travis-ci.org/cpe305/fall2016-project-bradyshutt.svg?branch=master)](https://travis-ci.org/cpe305/fall2016-project-bradyshutt)\r\n\r\n_Coplan: The College Planner_\r\n\r\nManage important due dates, deadlines, and test days with Coplan!\r\n\r\n## Project Structure\r\nThe way in which this project behaves is a little strange, \r\nso some explanation is necessary.\r\n\r\nThe core business logic of this project is written in Java. \r\nThe application works by letting the JVM continuously run the \r\nexported .jar file. The .jar then, indefinitely listens to \r\nit's STDIN in a blocking fashion [on purpose; That way the JVM\r\nisn't going crazy in an endless loop]. Upon receiving input, which\r\nmust be pre-formatted JSON, the running Java application will \r\nhandle the request, and eventually return a response by \r\nwriting a JSON message to STDOUT.\r\n\r\nA Node.js application is also running. Node.js acts as a\r\nbridge pattern between the Java process and the client. Node.js\r\nactually starts and manages the Java JAR. Upon receiving\r\nan HTTP request, node forwards the request to the JVM. \r\n\r\nThe Node.js process is essentially acting as the bridge\r\nbetween the client and the business logic.\r\n\r\n## Patterns Used\r\nI used many GOF design patterns in my project. Some of the more\r\nprevalent ones were the singleton pattern, interpreter pattern,\r\nand strategy pattern. \r\n\r\nThe Singleton pattern is used to manage the database instance,\r\nso it doesn't create multiple instances to the same database\r\nobject.\r\n\r\nThe Interpreter pattern is used to interpret requests, and\r\nthen respond to them.\r\n\r\nThe Strategy pattern goes hand-in-hand with the Interpreter pattern\r\nin this case. I have two strategies for interpreting commands. They \r\nare a JSON-formatted strategy, and a CLI-formatted strategy.\r\n\r\n## Class Diagram\r\n![Class Diagram](http://users.csc.calpoly.edu/~bshutt/305/cpe305FinalProj.png)\r\n\r\n## Picture of Application \r\n![Application Picture](/currentState.png)\r\n\r\n\r\n## Commands\r\n\r\nThe Java program handles all the business logic associated with\r\nCoplan, by communicating with a Node.js process via JSON-formatted\r\ncommands sent through STDIN/STDOUT.\r\n\r\nCommands are to be formatted in the following way:\r\n   - There are two essentail components: 'route', and 'data'\r\n   - 'route' specifies the endpoint you want to talk you\r\n   - 'data' specifies an object with keys and values pertinant to the endpoint\r\n   - If you attempt to access an endpoint without the needed requirements, an error message will be returned\r\n\r\n \r\n## Request Example \r\n    { \r\n       route: \"createUser\", \r\n       data: {\r\n          username: \"bshutt\",\r\n          firstName: \"Brady\",\r\n          lastName: \"Shutt\",\r\n          major: \"Computer Science\"\r\n       }\r\n    }\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}